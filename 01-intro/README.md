## 시간 복잡도

- 시간 복잡도란? 알고리즘이 다루는 데이터 개수에 대해 **몇 번의 연산**을 거쳐야 하는가. 작업에 필요한 연산의 수. 즉, 횟수가 포인트다.

## 공간 복잡도

- 공간 복잡도란? 데이터에 비해 얼마나 메모리 공간을 사용하는가. 메모리 양을 측정한다.

## Big-O 표기법

- 시간 복잡도와 공간 복잡도를 나타내기 위한 표기법

- 데이터를 많이 넣을 수록 얼마나 느려질까를 수학적으로 나타내는 것.

- 즉, 코드의 효율성을 측정하는 지표다.

- 표기법 예시

  - O(1)
  - O(log)
  - O(n)
  - O(n log n)
  - O(n²)
  - O(2^n)
  - O(n!)

- 여기서 n은 입력 데이터의 개수를 의미한다.

### Big-O 표기법 규칙

- <code>3n + 2</code> => <code>O(n)</code>로 상수를 제거하고 표현한다. 3과 2와 같은 상수가 복잡도에 미치는 영향이 미미하기 때문이다.

- <code>2n² + 5n + 10</code> => <code> O(n²)</code> 같은 이유로 최고차항보다 작은 항들은 모두 제거한다.

- 즉, 상수와 작은 항들에서만 차이가 있는 알고리즘들은 모두 같은 성능으로 표시된다.

### 시간복잡도 예시

#### O(1)

쌓여있는 쿠키들 중 가장 위의 쿠키를 집는 작업. 쿠키가 몇개 쌓여있더라도(상수) 한번에 하나의 쿠키를 집는다.<br>
즉, 항상 절차대로 하나씩 처리하는 경우.<br> 배열에서 특정 인덱스에 접근하여 값을 가져오는 경우나, 주어진 배열의 크기 상관없이 첫 번째 요소를 확인하는 경우 등이 해당한다.

##### O(1) 예시

- 배열의 특정 인덱스에 접근하기: 배열 arr에서 arr[5]와 같이 인덱스를 통해 특정 요소에 접근하는 것은 배열의 크기와 관계없이 항상 동일한 시간이 걸립니다.
- 해시 테이블에서 키로 값 찾기: 해시 함수를 이용해 키에 해당하는 주소를 즉시 계산하므로, 해시 테이블의 크기에 관계없이 상수 시간 안에 값을 찾을 수 있습니다.
- 연결 리스트의 헤드 노드(첫 번째 노드) 접근: 연결 리스트의 첫 번째 노드를 가리키는 포인터를 통해 즉시 접근할 수 있습니다.
- 스택에 데이터 삽입/삭제하기: 스택은 가장 최근에 들어온 데이터를 처리하는 LIFO(후입선출) 구조로, 데이터 삽입(push)과 삭제(pop)는 항상 최상단에서 일어나므로 상수 시간이 걸립니다.

#### O(log n)

사전에서 특정 단어를 찾는 것과 같다. 단어의 수에 따라 책장을 많이 넘겨야 될 수도 있지만, 첫페이지부터 찾는 것이 아니라 위치를 철자로 짐작해가며 찾기 때문에 n보다 작은 log n의 시간이 소요된다.
<br>문제 해결 과정에서 탐색 범위를 반복적으로 절반씩 줄여나가는 분할 정복 알고리즘에서 주로 나타난다.

##### O(log n) 예시

- 이진 탐색: 정렬된 배열에서 특정 값을 찾는 알고리즘. 탐색 범위를 매번 절반으로 줄여가므로 \(O(\log n)\)의 시간 복잡도를 가집니다.
- 이진 탐색 트리: 자료구조에서 특정 노드를 삽입, 삭제, 검색하는 연산.
- 이진 트리 순회: 트리의 높이에 비례하는 연산.
- 최대/최소 값 찾기: 이진 탐색 트리에서 최댓값이나 최솟값을 찾는 경우.

#### O(n)

체크박스에서 하나하나 체크를 하는 작업과 같다. 입력 데이터의 크기(n)가 증가함에 따라 연산 수행 횟수도 비례하여 선형적으로 증가한다.
<br>입력값의 모든 요소를 적어도 한 번씩 확인해야 하는 경우에 주로 사용한다.

##### O(n) 예시

- 선형 탐색: 정렬되지 않은 배열에서 특정 값을 찾을 때, 최악의 경우 모든 요소를 처음부터 끝까지 확인해야 한다.
- 배열의 모든 요소 출력: 배열에 있는 모든 요소를 한 번씩 출력하는 작업은 배열의 크기(\(n\))만큼 시간이 소요된다.
- 배열의 합계 계산: 배열의 모든 요소를 더하는 연산은 배열의 크기에 비례한다.
- 가장 큰 값 찾기: 배열에서 가장 큰 값을 찾기 위해 모든 요소를 한 번씩 비교하는 경우

#### O(n log n)

- 숫자가 적힌 무작위의 컵을 순서대로 정렬하는 것과 같다.

##### O(n log n) 예시

- 병합 정렬(Merge Sort): 배열을 절반씩 분할하고, 정렬된 서브 배열을 다시 병합하는 과정으로 전체를 정렬합니다. 분할 과정이 \(\log n\)번 일어나고, 매 병합 과정에서 \(n\)개의 요소를 처리하므로 \(O(n\log n)\)의 복잡도를 가진다.
- 힙 정렬(Heap Sort): 힙이라는 자료구조를 이용해 정렬하는 알고리즘.
- 퀵 정렬(Quick Sort): 평균적으로는 \(O(n\log n)\)의 복잡도를 가지지만, 최악의 경우 \(O(n^{2})\)가 될 수 있다.
- 트리 기반 정렬 알고리즘: 이진 탐색 트리를 활용한 정렬 방식.

#### O(n²)

- n명의 사람들이 각자 모든 다른 사람들과 악수를 하는 경우와 같다.

- 실제 식으로는 n(n-1)/2로 상수를 제거하면 n²가 된다.

##### O(n²) 예시

행렬 곱셈: \(n\times n\) 크기의 행렬을 곱하는 가장 기본적인 방법은 \(O(n^{3})\)이지만, 두 개의 \(n\times n\) 행렬을 곱할 때 각 요소를 비교하거나 처리하는 과정에서 \(O(n^{2})\)의 복잡도를 가지는 부분이 생길 수 있다.

- 모든 쌍의 거리 계산: \(n\)개의 점이 있을 때 모든 점 사이의 거리를 계산하려면, 한 점을 기준으로 나머지 모든 점과의 거리를 계산하는 작업을 모든 점에 대해 반복해야 하므로 \(O(n^{2})\)이 된다.

#### O(2ⁿ)

- 집에 있는 옷들을 모든 조합으로 코디해보는 것과 같다. 옷이 많아질수록 조합은 무수히 많아진다.
- 즉, n의 값이 커질수록 실행 시간은 급격하게 커지기 때문에 매우 작은 입력값에만 적용하는 것이 좋다.

##### O(2ⁿ) 예시

- 피보나치 수열(재귀 방식): 재귀적으로 피보나치 수를 계산하는 가장 단순한 방법은 \(n\)번째 피보나치 수를 계산하기 위해 \(n-1\)번째와 \(n-2\)번째 수를 계산하도록 두 번의 재귀 호출을 합니다. 이로 인해 호출 트리가 지수적으로 커지므로, 시간 복잡도는 \(O(2)\)이 됩니다.
- 부분집합 구하기: \(n\)개의 요소를 가진 집합의 모든 부분집합을 구하는 알고리즘은 총 2ⁿ개의 부분집합을 생성해야 하므로 \(O(2)\)의 복잡도를 가집니다.
- 최적화되지 않은 백트래킹: 여러 경우의 수를 탐색하며 정답을 찾는 백트래킹 알고리즘에서 최적화가 제대로 이루어지지 않으면 지수 시간 복잡도를 가질 수 있습니다.

#### O(n!)

- 각기 색이 다른 구슬들을 가능한 모든 순서대로 나열해보는 것과 같다.

- 입력값이 커질수록 실행 시간은 n배로 증가하기 때문에 극도로 작은 규모의 문제에만 적용하는 것이 좋다.

- 이 경우 실제 프로그래밍에서 사용하기에는 너무 비효율적이며, 더 나은 시간 복잡도를 가진 알고리즘을 찾아야 한다.

##### O(n!) 예시

- 외판원 문제(Traveling Salesman Problem)의 완전 탐색: \(n\)개의 도시를 모두 한 번씩 거쳐 다시 출발점으로 돌아오는 가장 짧은 경로를 찾는 문제입니다. 완전 탐색으로 이 문제를 해결할 경우, 모든 가능한 경로를 확인해야 하므로 \(O(n!)\)의 복잡도를 가집니다.
- 문자열의 모든 순열 생성: \(n\)개의 문자로 이루어진 문자열이 있을 때, 이 문자들을 재배열하여 만들 수 있는 모든 순열을 생성하는 알고리즘의 시간 복잡도는 \(O(n!)\)입니다.
- 다른 NP-완전 문제들의 완전 탐색: NP-완전 문제들은 다항식 시간(polynomial time, \(O(n^{k})\)) 내에 해결 가능한 알고리즘이 알려져 있지 않으며, 현재까지 알려진 가장 효율적인 알고리즘들은 대부분 지수 또는 계승 시간 복잡도를 가집니다.
